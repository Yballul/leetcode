

# 动态规划

### 1.零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
示例 2:

输入: coins = [2], amount = 3
输出: -1



假设给出的不同面额的硬币是[1, 2, 5]，目标是 120，问最少需要的硬币个数？

- 我们要分解子问题，分层级找最优子结构。**为什么要有最优子结构？首先，对于一个目标值而言，如果**

  **分解为了多个子问题，这里子问题是i-coin【j】的个数，然后子问题加了1就是本问题的解，则显然，对于**

  **每个j，这个表达式都成立，那么肯定就要子问题最优（数量最小了），然后+1后本问题的硬币数量肯定**

  **最小啦。**

- 这里我们使用**「自顶向下**」思想来考虑这个题目，然后用**「自底向上」**的方法来解题，
  体验算法的冰火两重天。

- dp[i]: 表示总金额为 i 的时候最优解法的硬币数（要不断比较并且更新这个数）

- 我们想一下：求总金额 120 有几种方法？下面这个思路关键了 !!!
  一共有 3 种方式，因为我们有 3 种不同面值的硬币。
  1.拿一枚面值为 1 的硬币 + 总金额为 119 的最优解法的硬币数量
    这里我们只需要假设总金额为 119 的最优解法的硬币数有人已经帮我们算好了，
    不需要纠结于此。(虽然一会也是我们自己算，哈哈)
    即：dp[119] + 1
  2.拿一枚面值为 2 的硬币 + 总金额为 118 的最优解法的硬币数
    这里我们只需要假设总金额为 118 的最优解法的硬币数有人已经帮我们算好了
    即：dp[118] + 1
  3.拿一枚面值为 5 的硬币 + 总金额为 115 的最优解法的硬币数
    这里我们只需要假设总金额为 115 的最优解法的硬币数有人已经帮我们算好了
    即：dp[115] + 1

  所以，总金额为 120 的最优解法就是上面这三种解法中最优的一种，也就是硬币数最少
  的一种，我们下面试着用代码来表示一下：

  **dp[120] = Math.min(dp[119] + 1, dp[118] + 1, dp[115] + 1);**

  推导出「状态转移方程」：
  **dp[i] = Math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...)**
  其中 coin 有多少种可能，我们就需要比较多少次，那么我们到底需要比较多少次呢？
  当然是 coins 数组中有几种不同面值的硬币，就是多少次了~ 遍历 coins 数组，
  分别去对比即可

  ```javascript
  /**
   * @param {number[]} coins
   * @param {number} amount
   * @return {number}
   */
  
  var coinChange = function(coins, amount) {
    let dp = new Array( amount + 1 ).fill( Infinity );
    dp[0] = 0;
    
    for (let i = 1; i <= amount; i++) {
      for (let coin of coins) {
        if (i - coin >= 0) {
          dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
      }
    }
    
    return dp[amount] === Infinity ? -1 : dp[amount];
  }
  
  /*
    先来一波超时算法：DFS
    第 15 个测试用例就超时了 !!
  */
  // var coinChange = function(coins, amount) {
  //   let least = Infinity, len = coins.length;
    
  //   // backtrack[总金额, 硬币数, 下一个硬币的索引]
  //   function backtrack(sum, num, index) {
  //     // 如果总金额超过了 amount ，终止本次递归
  //     if (sum > amount) return ;
  //     if (least !== Infinity && num >= least) return ;
      
  //     // 如果总金额等于 amount，比较最小数量，终止本次递归
  //     if (sum === amount) {
  //       return least = Math.min(least, num);
  //     }
      
  //     // 继续遍历
  //     for (let i = index; i < len; i++) {
  //       sum += coins[i];
  //       backtrack(sum, num + 1, index);
  //       sum -= coins[i];
  //     }
  //   };
  //   backtrack(0, 0, 0);
    
  //   return least === Infinity ? -1 : least;
  // };
  
  
  ```

  

### 2.01背包

**有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？**



为方便讲解和理解，下面讲述的例子均先用具体的数字代入，即：eg：number＝4，capacity＝8

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190810164615141.png)

在解决问题之前，为描述方便，首先定义一些变量：**Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值**，同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。

1、建立模型，即求max(V1X1+V2X2+…+VnXn)；

2、寻找约束条件，W1X1+W2X2+…+WnXn<capacity；

3、寻找递推关系式，面对当前商品有两种可能性：

- **包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；**
- **还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。**

------

其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；

由此可以得出递推关系式：

- j<w(i) V(i,j)=V(i-1,j)
- j>=w(i) V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝

------

这里需要解释一下，为什么能装的情况下，需要这样求解（这才是本问题的关键所在！）：

可以这么理解，**如果要到达V(i,j)这一个状态有几种方式**？

**肯定是两种，第一种是第i件商品没有装进去，第二种是第i件商品装进去了**。没有装进去很好理解，就是V(i-1,j)；装进去了怎么理解呢？如果装进去第i件商品，那么装入之前是什么状态，肯定是V(i-1,j-w(i))。由于最优性原理（上文讲到），V(i-1,j-w(i))就是前面决策造成的一种状态，后面的决策就要构成最优策略。两种情况进行比较，得出最优。

4、填表，首先初始化边界条件，V(0,j)=V(i,0)=0；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190810165633366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70)

然后一行一行的填表：

- 如，i=1，j=1，w(1)=2，v(1)=3，有j<w(1)，故V(1,1)=V(1-1,1)=0；
- 又如i=1，j=2，w(1)=2，v(1)=3，有j=w(1),故V(1,2)=max｛
  V(1-1,2)，V(1-1,2-w(1))+v(1) ｝=max｛0，0+3｝=3；
- 如此下去，填到最后一个，i=4，j=8，w(4)=5，v(4)=6，有j>w(4)，故V(4,8)=max｛
  V(4-1,8)，V(4-1,8-w(4))+v(4) ｝=max｛9，4+6｝=10……

------

所以填完表如下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190810165740701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70)

5、表格填完，最优解即是V(number,capacity)=V(4,8)=10。

```c++
#include<iostream>
using namespace std;
#include <algorithm>
 
int main()
{
	int w[5] = { 0 , 2 , 3 , 4 , 5 };			//商品的体积2、3、4、5
	int v[5] = { 0 , 3 , 4 , 5 , 6 };			//商品的价值3、4、5、6
	int bagV = 8;					        //背包大小
	int dp[5][9] = { { 0 } };			        //动态规划表
 
	for (int i = 1; i <= 4; i++) {
		for (int j = 1; j <= bagV; j++) {
			if (j < w[i])
				dp[i][j] = dp[i - 1][j];
			else
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
		}
	}
 
	//动态规划表的输出
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 9; j++) {
			cout << dp[i][j] << ' ';
		}
		cout << endl;
	}
 
	return 0;
}
```

------------------

### 3.三角形最小路径和

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

 

例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

![image-20200927170550700](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200927170550700.png)

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<vector<int>> f(n, vector<int>(n));
        f[0][0] = triangle[0][0];
        for (int i = 1; i < n; ++i) {
            f[i][0] = f[i - 1][0] + triangle[i][0];
            for (int j = 1; j < i; ++j) {
                f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j];
            }
            f[i][i] = f[i - 1][i - 1] + triangle[i][i];
        }
        return *min_element(f[n - 1].begin(), f[n - 1].end());
    }
};
```

### 4.解码方法

'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

题目数据保证答案肯定是一个 32 位的整数。

 

示例 1：

输入："12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2：

输入："226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
示例 3：

输入：s = "0"
输出：0
示例 4：

输入：s = "1"
输出：1
示例 5：

输入：s = "2"
输出：1


提示：

1 <= s.length <= 100
s 只包含数字，并且可以包含前导零。

这个题目类似于跳台阶题目，但比那个多了很多限制条件。最核心的点就是，假定dp【i】表示在在字符串的字符个数为i+1时候最多的解码方法数，那么dp【i】=dp[i-1]+dp[i-2],因为要不就是当前第i+1个字符（注意数组下标从0开始，所以dp【i】是对应i+1个字符）直接充当一个个位数，然后解析成字母，那么方法数与前i个字符的解码方法数是相同的（前i个字符的解码方法数我们是知道的），然后或者是它跟第i个字符来组成一个十位数，解析出来，此时应该是前i-1个字符的方法数。但是，由于会有0的出现，或者是组成的十位数是超过了26，那么这就样分情况讨论了。

第一种情况：如果说第i+1个字符是0的话，那么它只有可能与前面那位组成十位数才能被解析成字母。算出这个十位数，如果这个十位数大于26或者等于0（也就是说第i个字符都为0）的话，那么这个字符串就不可能被解析，因为第i+1个字符不能单独存在，而它与前面那个字符组合起来又不能被解析出来，所以整段字符串解析不出来。

第二种情况：如果说第i+1个字符是非0的话，那么就要看一下她前一位是不是0，如果是0的话，那么只能调用dp【i-1】，如果不是的话，那么就根据情况，如果组成十位数是大于26，那么就dp【i-1】，如果不大于，那么就dp【i-1】+dp【i-2】

对于最小子问题的讨论：

**先看第1个字符是不是0**，如果是0，直接return0就好了，如果不是，才进行下面程序，dp【0】初始为1

**然后看第二个字符是不是0**，如果是0，那么算第一二位组成的十位数，如果是>26，那么不可能解析

如果是不大于，那么可以解析，dp【1】=1

**如果第二个字符不是0**，那么也是按套路解析，如果满足条件，dp【1】=2，否则为1

```c++
class Solution {
public:
    int numDecodings(string s) {
        int num=0;
        int dp[100]={};
        if(s[0]=='0')
        return 0;
        else
        dp[0]=1;
        num=(s[0]-'0')*10+s[1]-'0';
        if(s[1]=='0')
        {
            if(num>26)
            return 0;
            else
            dp[1]=1;
        }
        else
        {
            if(num>26)
            dp[1]=1;
            else
            dp[1]=2;
        }
        for(int i=2;i<s.size();i++)
        {
          num=(s[i-1]-'0')*10+s[i]-'0';
          if(s[i]=='0')
          {
             if(num>26||num==0)
             return 0;
             else 
             {
                 dp[i]=dp[i-2];
             }
          }
          else if(s[i-1]=='0')
          {
              dp[i]=dp[i-1];
          }
          else
          {
             if(num>26)
             dp[i]=dp[i-1];
             else
             dp[i]=dp[i-1]+dp[i-2];
          }
        }
        
        return dp[s.size()-1];
    }
};
```

```java
class Solution {
    public int numDecodings(String s) {
         if(s.charAt(0)=='0')
         return 0;
         
         if(s.length()<=1)
         return s.length();
         int[] dp=new int[s.length()+1];
        
         dp[0]=1;
         dp[1]=1;
         for(int i=2;i<=s.length();i++)
         {
             int sum=(s.charAt(i-2)-'0')*10+(s.charAt(i-1)-'0');
             if(s.charAt(i-1)=='0')
             {
                 if(sum>26||sum==0)
                 return 0;
                 else
                 dp[i]=dp[i-2];
             }
             else
             {
                 if(s.charAt(i-2)=='0'||sum>26)
                 dp[i]=dp[i-1];
                 else
                 dp[i]=dp[i-1]+dp[i-2];

             }
         }
         return dp[s.length()];
    }
}
```



### 5.接雨水

![image-20201026100924504](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201026100924504.png)

即，当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度

为了的到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一波。

这其实是有重复计算的。

我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight）。

避免的重复计算，者就用到了动态规划。

当前位置，左边的最高高度，是前一个位置的最高高度和本高度的最大值。

即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);

从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);

这样就找到递推公式。

是不是地推公式还挺简单的，其实动态规划就是这样，只要想到了递推公式，其实就比较简单了。

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.size() <= 2) return 0;
        vector<int> maxLeft(height.size(), 0);
        vector<int> maxRight(height.size(), 0);
        int size = maxRight.size();

        // 记录每个柱子左边柱子最大高度
        maxLeft[0] = height[0];
        for (int i = 1; i < size; i++) {
            maxLeft[i] = max(height[i], maxLeft[i - 1]);
        }
        // 记录每个柱子右边柱子最大高度
        maxRight[size - 1] = height[size - 1];
        for (int i = size - 2; i >= 0; i--) {
            maxRight[i] = max(height[i], maxRight[i + 1]);
        }
        // 求和
        int sum = 0;
        for (int i = 0; i < size; i++) {
            int count = min(maxLeft[i], maxRight[i]) - height[i];
            if (count > 0) sum += count;
        }
        return sum;
    }
};
```

### 6.购买股票的最佳时机





![image-20201030210110262](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201030210110262.png)

![image-20201030210256336](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201030210256336.png)

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 动态规划解法
        
        // 0.初始判断
        if(prices.empty()) return 0;
        
        int dp[prices.size()][2];
        // 1.初始状态
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        // 2.状态转移
        for(int i = 1; i<prices.size();i++){
            // 3.状态转移方程
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
        }
        return dp[prices.size()-1][0];
    }
};
```

### 7.最大子序列和



![image-20201031093752209](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201031093752209.png)

1.动态规划

先确定状态 可以这样定义dp【i】，dp【i】是指以索引值为i的元素为序列结尾的最大的子序列和。状态转换方程就比较有技巧了，因为我们知道，对于一个i来说，如果dp【i-1】确定了，那么就代表我们知道了i-1为结尾的最大的子序列的和。注意，因为以索引值i的元素为结尾的子序列，或是包含了它前一个元素的序列，或是只含有它本身的一个序列，那么我们就知道了，如果是含有前一个元素的话，那么肯定是以那个前一个元素为最后一个元素的最大和的子序列为基础，再加上那个本元素的值。那么就知道了，dp【i】是在dp【i-1】+nums【i】和nums【i】之间取最大值

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size()==1)
        return nums[0];
        vector<int>dp(nums.size(),0);
        dp[0]=nums[0];
        int res=dp[0];
        for(int i=1;i<nums.size();i++)
        {
            dp[i]=max(dp[i-1]+nums[i],nums[i]);
            res=max(dp[i],res);
        }
        return res;
    }
};
```

2.分治法

分治法是将整个数组切分成几个小组，然后每个小组再切分成几个更小的小组，一直到不能继续切分也就是只剩一个数字为止。每个小组会计算出最优值，汇报给上一级的小组，一级一级汇报，上级拿到下级的汇报找到最大值，得到最终的结果。和归并排序的算法类似，先切分，再合并结果。

这个问题中的关键就是如何切分这些组合才能使每个小组之间不会有重复的组合（有重复的组合意味着有重复的计算量），这个问题应该困扰了不少的同学，我在学习理解的时候也花了不少时间。

首先是切分分组方法，就这个案例中的例子来，我们有一个数组 [-2,1,-3,4,-1,2,1,-5,4] ，一共有 9 个元素，我们 center=(start + end) / 2 这个原则，得到中间元素的索引为 4 ，也就是 -1，拆分成三个组合：

[-2,1,-3,4,-1]以及它的子序列（在-1左边的并且包含它的为一组）
[2,1,-5,4]以及它的子序列（在-1右边不包含它的为一组）
任何包含-1以及它右边元素2的序列为一组（换言之就是包含左边序列的最右边元素以及右边序列最左边元素的序列，比如 [4,-1,2,1]，这样就保证这个组合里面的任何序列都不会和上面两个重复）
以上的三个组合内的序列没有任何的重复的部分，而且一起构成所有子序列的全集，计算出这个三个子集合的最大值，然后取其中的最大值，就是这个问题的答案了。

然而前两个子组合可以用递归来解决，一个函数就搞定，第三个跨中心的组合应该怎么计算最大值呢？

答案就是先计算左边序列里面的包含最右边元素的子序列的最大值，也就是从左边序列的最右边元素向左一个一个累加起来，找出累加过程中每次累加的最大值，就是左边序列的最大值。

同理找出右边序列的最大值，就得到了右边子序列的最大值。左右两边的最大值相加，就是包含这两个元素的子序列的最大值。

在计算过程中，累加和比较的过程是关键操作，一个长度为 n 的数组在递归的每一层都会进行 n 次操作，分治法的递归层级在 logNlogN 级别，所以整体的时间复杂度是 O(nlogn)O(nlogn)，在时间效率上不如动态规划的 O(n)O(n) 复杂度。

分治法的思路是这样的，其实也是分类讨论。

连续子序列的最大和主要由这三部分子区间里元素的最大和得到：

第 1 部分：子区间 [left, mid]；
第 2 部分：子区间 [mid + 1, right]；
第 3 部分：包含子区间[mid , mid + 1]的子区间，即 nums[mid] 与nums[mid + 1]一定会被选取。
对它们三者求最大值即可。

```c++
public int maxSubArray(int[] nums) {
    return maxSubArrayDivideWithBorder(nums, 0, nums.length-1);
}

private int maxSubArrayDivideWithBorder(int[] nums, int start, int end) {
    if (start == end) {
        // 只有一个元素，也就是递归的结束情况
        return nums[start];
    }

    // 计算中间值
    int center = (start + end) / 2;
    int leftMax = maxSubArrayDivideWithBorder(nums, start, center); // 计算左侧子序列最大值
    int rightMax = maxSubArrayDivideWithBorder(nums, center + 1, end); // 计算右侧子序列最大值

    // 下面计算横跨两个子序列的最大值

    // 计算包含左侧子序列最后一个元素的子序列最大值
    int leftCrossMax = Integer.MIN_VALUE; // 初始化一个值
    int leftCrossSum = 0;
    for (int i = center ; i >= start ; i --) {
        leftCrossSum += nums[i];
        leftCrossMax = Math.max(leftCrossSum, leftCrossMax);
    }

    // 计算包含右侧子序列最后一个元素的子序列最大值
    int rightCrossMax = nums[center+1];
    int rightCrossSum = 0;
    for (int i = center + 1; i <= end ; i ++) {
        rightCrossSum += nums[i];
        rightCrossMax = Math.max(rightCrossSum, rightCrossMax);
    }

    // 计算跨中心的子序列的最大值
    int crossMax = leftCrossMax + rightCrossMax;

    // 比较三者，返回最大值
    return Math.max(crossMax, Math.max(leftMax, rightMax));
}

```

### 8.单词拆分1（判断能不能拆，就动态规划吧）



![image-20201121101401403](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201121101401403.png)

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
          vector<bool>dp(s.size()+1,false);
          dp[0]=true;
        //  for(int i=0;i<wordDict.size();i++)
        //  {
        //      for(int j=0;j<dp.size();j++)
        //      {
        //          if(j<wordDict[i].size())
        //          continue;
        //          else
        //          {
        //              bool canuse=true;
        //              for(int k=0;k<wordDict[i].size();k++)
        //              {
        //                  if(s[j-k-1]!=wordDict[i][wordDict[i].size()-k-1])
        //                  {
        //                         canuse=false;
        //                         break;
        //                  }
        //              }
        //              dp[j]=dp[j-wordDict[i].size()]&&canuse;
        //          }
        //      }
        //  }
          for(int j=0;j<dp.size();j++)
         {
             for(int i=0;i<wordDict.size();i++)
             {
                 if(j<wordDict[i].size())
                 continue;
                 else
                 {
                     //先假设前面的i个字符中是可以包含目标单词，而且目标单词是在这i个字符的最后
                     bool canuse=true;
                     for(int k=0;k<wordDict[i].size();k++)
                     {
                         //从最后一个字符开始比较，看看前i个字符里面字符是不是和这个单词的每个字符对应
                         if(s[j-k-1]!=wordDict[i][wordDict[i].size()-k-1])
                         {
                                canuse=false;
                                break;
                         }
                     }
                     //对弈j而言，dp【j】的正确与否，是取决于它除去第i个单词之后的字符串是不是可以可拆分的，所以这里写成这样
                     dp[j]=dp[j-wordDict[i].size()]&&canuse;
                     if(dp[j])
                     //意识到，当dp【j】其实就代表j个字符组成的字符串已经找到了一种符合规则的拆分方法了，要break
                     break;
                 }
             }
         }
         return dp[s.size()];
    }
};
```

### 9.最大湍流子数组

![image-20201225101327554](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201225101327554.png)

```c++
class Solution {
public:
    int maxTurbulenceSize(vector<int>& arr) {
        //dp定义 dp【i】代表了以索引值为i的元素作为结尾的湍流子数组的长度。
        if(arr.size()<=1)
        return arr.size();
        int res=0;
        vector<int>dp(arr.size());
        dp[0]=1;
        if(arr[1]!=arr[0])
        dp[1]=2;
        else
        dp[1]=0;
        res=max(dp[1],dp[0]);
        for(int i=2;i<arr.size();i++)
        {
            if(arr[i-2]>arr[i-1]&&arr[i]>arr[i-1]||arr[i-2]<arr[i-1]&&arr[i]<arr[i-1])
            {
               if(dp[i-1]==0)
               dp[i]=3;
               else
               dp[i]=dp[i-1]+1;
               res=max(dp[i],res);
            }
            else if(dp[i]!=dp[i-1])
            dp[i]=2;
            else
            dp[i]=1;
        }
        return res;
    }
};//我的版本
```

首先我们要看懂题目的意思。我们可以把数组中 A[i+1] > A[i] 称为“上升段”，把 A[i+1] < A[i] 称为“下降段”，A[i+1] == A[i] 的称为“水平段”。那么，我们要找的是一段交替上升下降的子数组。例如示例输入 [9,4,2,10,7,8,8,1,9]：

![波形子数组示意图](https://pic.leetcode-cn.com/85bd024ca1de1c4a6953b552b3868085c9243a8ba8fddab344d4064ce905f368.jpg)

我们要找的就是这种上升和下降交替的波形子数组，也也是题目叫“湍流”（turbulent）子数组的原因。

我们发现，波形数组有一个很明显的递推关系：我们在已有的波形子数组上，再加一段上升或者下降段，就可以得到更长的波形子数组。这样一个递推关系提示我们可以用动态规划的方法来解这道题。

我们可以这样定义子问题：定义 f(k)f(k) 为数组 A[0..k) 中，以 A[k-1] 结尾的最长波形子数组。注意这里的附加条件以 A[k-1] 结尾，这是因为只有最右侧的波形子数组才可以和新加入的上升/下降段连接起来。这是子数组类动态规划题目中常见的定义子问题方法，例如 53. 最大子数组和 中的子问题也是有这种方法定义的。

需要注意的是，波形数组的连接是有条件的。如果波形数组的最后一段是“上升”，就需要连上一段“下降”才是合法的波形数组；如果波形数组的最后一段是“下降”，就需要连上一段“上升”才是合法的波形数组。我们在写子问题递推关系的时候需要注意这一点。

那么，我们需要分类讨论子问题的递推关系。对于子问题 f(k)f(k)：

如果 f(k-1)f(k−1) 波形数组的最后一段是“上升”，且 A[k-1] 和 A[k-2] 之间是“上升”，那么 f(k) = 2f(k)=2；
如果 f(k-1)f(k−1) 波形数组的最后一段是“上升”，且 A[k-1] 和 A[k-2] 之间是“下降”，那么 f(k) = f(k-1) + 1f(k)=f(k−1)+1；
如果 f(k-1)f(k−1) 波形数组的最后一段是“下降”，且 A[k-1] 和 A[k-2] 之间是“上升”，那么 f(k) = f(k-1) + 1f(k)=f(k−1)+1；
如果 f(k-1)f(k−1) 波形数组的最后一段是“下降”，且 A[k-1] 和 A[k-2] 之间是“下降”，那么 f(k) = 2f(k)=2；
如果 A[k-1] 和 A[k-2] 之间是“水平”，那么 f(k) = 1f(k)=1；
什么？一个看似简单的问题竟然要分这么多情况考虑，是不是看得头都大了？

通常来说，如果你发现子问题的递推关系过于复杂，那可能是子问题定义得不是很好。既然我们总是要判断波形数组的最后一段是上升还是下降，那我们为何不在子问题定义时就把它们区分开来呢？

是的，我们可以定义两个子问题，分别对应最后一段上升和下降的波形子数组：

子问题 f(k)f(k) 为数组 A[0..k) 中，以 A[k-1] 结尾，且最后一段为“上升”的最长波形子数组；
子问题 g(k)g(k) 为数组 A[0..k) 中，以 A[k-1] 结尾，且最后一段为“下降”的最长波形子数组。
那么我们的子问题递推关系就变得清晰了起来：

如果 A[k-1] 和 A[k-2] 之间是“上升”，那么 f(k) = g(k-1) + 1f(k)=g(k−1)+1，g(k) = 1g(k)=1；
如果 A[k-1] 和 A[k-2] 之间是“下降”，那么 f(k) = 1f(k)=1，g(k) = f(k-1) + 1g(k)=f(k−1)+1；
如果 A[k-1] 和 A[k-2] 之间是“水平”，那么 f(k) = 1f(k)=1，g(k) = 1g(k)=1。

### 10.交错字符串

![image-20210329090028059](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210329090028059.png)

![.](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210329085957589.png)

在这里，向下走相当于选择第二个子串中的一个字母，而如果向右走相当于选择第一个串中的字母。

![image-20210329090105328](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210329090105328.png)

```java

class Solution {
    //动态规划法，我只能说太妙了啊
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();
        if (s3.length() != m + n) return false;
        // 动态规划，dp[i,j]表示s1前i字符能与s2前j字符组成s3前i+j个字符；
        boolean[][] dp = new boolean[m+1][n+1];
        dp[0][0] = true;
        for (int i = 1; i <= m && s1.charAt(i-1) == s3.charAt(i-1); i++) dp[i][0] = true; // 不相符直接终止
        for (int j = 1; j <= n && s2.charAt(j-1) == s3.charAt(j-1); j++) dp[0][j] = true; // 不相符直接终止
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = (dp[i - 1][j] && s3.charAt(i + j - 1) == s1.charAt(i - 1))
                    || (dp[i][j - 1] && s3.charAt(i + j - 1) == s2.charAt(j - 1));
            }
        }
        return dp[m][n];
    }
}
```

### 11.最大正方形

![image-20210419142808565](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210419142808565.png)

![image-20210419142912754](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210419142912754.png)

![image-20210419142939633](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210419142939633.png)

![image-20210419143007976](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210419143007976.png)

public int maximalSquare(char[][] matrix) {
    // base condition
    if (matrix == null || matrix.length < 1 || matrix[0].length < 1) return 0;

```java
int height = matrix.length;
int width = matrix[0].length;
int maxSide = 0;

// 相当于已经预处理新增第一行、第一列均为0
int[][] dp = new int[height + 1][width + 1];

for (int row = 0; row < height; row++) {
    for (int col = 0; col < width; col++) {
        if (matrix[row][col] == '1') {
            dp[row + 1][col + 1] = Math.min(Math.min(dp[row + 1][col], dp[row][col + 1]), dp[row][col]) + 1;
            maxSide = Math.max(maxSide, dp[row + 1][col + 1]);
        }
    }
}
return maxSide * maxSide;
```
}

# 双指针

## a.普通情况

### 1.三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]

**一定要先排好序，因为只有排好序了，才能知道双指针中应该移动哪个指针。**首先要有一个大的循环（定下第一个数字），该循环从索引0开始，一直到达倒数第二个元素。对于每一个定数，设立两个指针，头指针刚开始在nums首，尾指针刚开始在nums尾部。然后要知道，因为数组是升序排序，如果说对于某一状态三数之和大于target，那么尾指针应该是要向左走，而不是头指针往右走，因为如果头指针往右走，那么三数之和又会越偏离target，所以要让大数（尾指针指向的数字）减小，然后接近target，同理，当小于target，那么就头指针往右走。终止小循环的条件就是，头尾指针首次碰到了定数的索引。（其实这下子会超时，属于自己的想法）

更好地想法：对于一个定数，从定数后的一个数开始作为left指针，这样就不会超时。

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
            // 错误去重方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后
                    //应该联系前面那段000的情况！！
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};
```



### 2.四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

示例：

给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int k = 0; k < nums.size(); k++) {
            // 这种剪枝是错误的，这道题目target 是任意值 
            // if (nums[k] > target) {
            //     return result;
            // }
            // 去重
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            for (int i = k + 1; i < nums.size(); i++) {
                // 正确去重方法
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {
                    if (nums[k] + nums[i] + nums[left] + nums[right] > target) {
                        right--;
                    } else if (nums[k] + nums[i] + nums[left] + nums[right] < target) {
                        left++;
                    } else {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        // 去重逻辑应该放在找到一个四元组之后
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }

            }
        }
        return result;
    }

};
```



### 3.山脉数组

我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：

B.length >= 3
存在 0 < i < B.length - 1 使得 B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]
（注意：B 可以是 A 的任意子数组，包括整个数组 A。）

给出一个整数数组 A，返回最长 “山脉” 的长度。

如果不含有 “山脉” 则返回 0。

 

示例 1：

输入：[2,1,4,7,3,2,5]
输出：5
解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。
示例 2：

输入：[2,2,2]
输出：0
解释：不含 “山脉”。

```c++
 if ( A.size() <= 2) {
            return 0;
        }
        int res = 0;
        for (int i = 1; i < A.size() - 1; i++) {
            //先找到顶峰，顶峰元素比他相邻的元素都要大
            if (A[i - 1] < A[i] && A[i + 1] < A[i]) {
                int l = i - 1;//再设立左右指针
                int r = i + 1;
                while (l > 0 && A[l - 1] < A[l]) {
                    l--;
                }
                while (r < A.size() - 1 && A[r + 1] < A[r]) {
                    r++;
                }
                res = max(res,r-l+1);
            }
        }
        return res;
    }
};
```

### 4.合并区间

![image-20201020120146249](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201020120146249.png)



这里设定，左指针是代表现拼接区间的左端点值所在一维vector在二维vector的索引值（排序后），右指针是代表现拼接区间的右端点值所在一维vector在二维vector的索引值（排序后）

对于所给到的二维vector，先根据每个一维vector的左端点的大小进行排序。那么，这时候，不妨就把第一个一维vector的左端点作为现拼接区间的左端点，右端点作为拼接区间的右端点。那么，遍历整个二维vector，如果对于某个vector，其左端点小于或等于了现拼接区间的右端点，那么就说明这个区间是跟现拼接的区间有交集，也就说可以参与合并的。那么接着就比较现今区间的右端点和该区间的右端点的大小值，设定新的现区间的右端点。那如果那个一维vector代表的区间的左端点大于现今右端点，就说不能参与合并，那么就说明遇到不合法的情况了是吧，那么就将现今拼接区间作为答案的一部分。然后左右指针要分别弄到这个不合法的区间的左右端点是吧。

但现在要注意，有一个特殊情况就是到了最后一个区间问题。最后一个区间是合法的话，那么i还会继续进行加下去（就说继续遍历），但事实上后面已经没有区间了，这不是不合法的情况，所以不会停止遍历。那么就说到了最后一个区间，就要打住了，得出一个新的答案区间。这里有两个情况，一个就是最后一个区间是可拼接的，那么直接按上述原则更新现拼接区间的右端点值，然后直接作为答案一部分。如果是不合法不能拼接的呢？那就说明现今拼接区间已经完成，不包括最后区间了，那么先将现拼接的压入答案组，然后呢，这个最后的区间作为单独一个答案部分就可了。

```c++{
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(intervals.size() < 2) return intervals;
        vector<vector<int>> res;
        vector<int>middle;
        int right=0;
        int left=0;
        sort(intervals.begin(), intervals.end(),
                [](const vector<int>& x, const vector<int>& y){
                    return x[0] < y[0];
                });
        for(int i=1;i<intervals.size();i++)
        {
            if(intervals[i][0]<=intervals[right][1])
            {
                if(intervals[right][1]<intervals[i][1])
                right=i;
                if(i==intervals.size()-1)
                {
                middle.push_back(intervals[left][0]);
                middle.push_back(intervals[right][1]);
                res.push_back(middle);
                middle.clear();
                }
            }
            else
            {
                middle.push_back(intervals[left][0]);
                middle.push_back(intervals[right][1]);
                res.push_back(middle);
                middle.clear();
                left=i;
                right=i;
                if(i==intervals.size()-1)
                {
                middle.push_back(intervals[left][0]);
                middle.push_back(intervals[right][1]);
                res.push_back(middle);
                }
                
            }
        }
        return res;
    }
};
```



## b.滑动窗口

### 1.长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

 

示例：

输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

这道题目最简单的解法自然是枚举每个数组起点和终点，这种解法的时间复杂度是O(N^2)

通过分析可以发现，这种解法进行了很多重复计算，首先是对于状态的重复计算，比如当start为0时，我们计算了区间[0,0], [0,1], [0,2],...等的和，但当start为1时，我们又重新计算了区间[1,1], [1,2], ....,的和，但事实上，这些区间的值是可以根据上一次计算的结果直接得到的，如区间[1,2]等于区间[0,2]减去nums[0]的值。换句话说，我们可以根据之前计算得到的结果来推断还未进行计算的结果，这也为剪枝带来了可能。

考虑这样一个例子，给定数组为[2,3,1,2,4,3]，并给定要求的最小和s为7，通过第一次枚举，我们得知子数组[2,3],[2,3,1]都是小于7的，那我们也就没有必要在接下来的阶段对子数组[3],子数组[3,1]进行枚举检查了，因为他们的和一定是小于7的。若实现了这种剪枝，时间复杂度便可以得到大幅的优化。

那么如何实现这样的剪枝呢？考虑这样一种情形，数轴上存在一个滑动窗口，假设其左右端点分别为L和R。首先我们移动R，使得滑动窗口的区间满足给定的条件，然后我们再移动L，直到滑动区间不再满足给定的条件，如此循环往复，并在其过程中记录最优值。继续之前的例子，如图所示，过程如下：

1. 滑动窗口的长度为0，位于数轴的最左端
2. 滑动窗口右端R开始移动，直到区间满足给定的条件，也就是和大于7，停止于第三个元素2，记录下来当前的最优长度为4
3. 滑动窗口左端L开始移动，并停止于第一个元素3，此时区间和为6，使得区间和不满足给定的条件
4. 滑动窗口右端R继续移动，停止于第四个元素4，在过程中，最优长度仍然为4
5. 滑动窗口左端L移动至第三个元素2，过程中更新最优长度为3
6. 滑动窗口右端R移动至最后一个元素3,
7. 滑动窗口左端L移动至最后一个元素，并在过程中更新最优长度为2

![img](https://pic2.zhimg.com/80/v2-768819bdef15387ed18ba11fcc72e0d2_720w.jpg)

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        if(nums.size()==0)
         return 0;
         int left=0;
         int right=0;
         int sum=nums[0];
         int res=INT_MAX;
         
         while(right<nums.size())
         {           
             if(sum>=s)
             {
                res=min(res,right-left+1);
                sum-=nums[left];//如果sum满足大于等于s，那么左指针尝试右移，然后sum要减去这个原来左指针所指向元素
                left++;
               
             }
             else
             {
                 right++;
                 if(right<nums.size())
                 sum+=nums[right];//如果right没到最右
             }
         }
         if(res!=INT_MAX)
         return res;
         else
         return 0;
    }
};
```

```c++
lass Solution {
public://其他人版本
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
时间复杂度：O(n)
空间复杂度：O(1)
```

### 2.无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size()<=1)
        {
            return s.size();
        }
        int i=0;
        int j=0;
        int res=0;
        while(j<s.size())
        {
            if(j!=i)
            {
            //有两种情况需要更新长度，第一种就是j移到了不符合题意的位置，第二种就是j移到了最后
             //一定是第一种放前面。举例：对于acdd，那么如果第一种放在前面，j移到最后了才不符合题意，先进行第一种操作，长度不会             多加1，而且更新了i的位置，那么放到第二种情况去算也是对的。
            for(int k=i;k<j;k++)
            {
                if(s[k]==s[j])
                {
                    res=max(res,j-i);
                    i=k+1;                  
                    break;
                }
            }
            }
            if(j==s.size()-1)
            {
             res=max(res,j-i+1);
             //j已经到头了（比如说所给的字符串是au这种，没有重复的）,那么就要算长度了，而且跟上面算方法不一样，要加1；
            }
            j++;
        }
        return res;      
    }
};
```

### 3.最大连续1的个数

给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。

 

示例 1：

输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
示例 2：

输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。

求能够装下指定个数K个0的窗口的最大长度即可

```c++
class Solution {
public:
    int longestOnes(vector<int>& A, int K) {
       int count=0;//统计0的个数
        int left=0;//滑动窗口区间左端点
        int right=0;//滑动窗口区间右端点
        int res=0;//最终结果
        //滑动窗口表示的区间为[left,right)，左闭右开
        while(right<A.size()){
            if(A[right++]==0){//窗口扩充一个元素，如果为0则count++；
                count++;
            }
            while(count>K){//当窗口内0的个数超过k时候，开始收缩窗口
                if(A[left++]==0){//如果刚滑出窗口的元素是0，则count--;
                    count--;
                }
            }
            //此时count<=K,保存窗口的最大宽度
            res=max(res,right-left);
        }
        return res;

    }
};//这种方法就不会有bug，记住是左闭右开。而且这种方法保证了i不会大于j
```

## c.快慢指针

### 1.删除链表中倒数第N个节点

![image-20201115095351657](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201115095351657.png)

思路
双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

思路是这样的，但要注意一些细节。

分为如下几步：

首先这里我推荐大家使用虚拟头结点，这样方面处理删除实际头结点的逻辑，如果虚拟头结点不清楚，可以看这篇： 链表：听说用虚拟头节点会方便很多？

定义fast指针和slow指针，初始值为虚拟头结点，如图：

![19.删除链表的倒数第N个节点.png](https://pic.leetcode-cn.com/1603008187-jHqmnu-19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png)

fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图：

![19.删除链表的倒数第N个节点1.png](https://pic.leetcode-cn.com/1603008199-FUreJH-19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png)

fast和slow同时移动，之道fast指向末尾，如题：

![19.删除链表的倒数第N个节点2.png](https://pic.leetcode-cn.com/1603008221-HlKNOO-19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png)

删除slow指向的下一个节点，如图：

![19.删除链表的倒数第N个节点3.png](https://pic.leetcode-cn.com/1603008232-CPZCYu-19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png)

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;
        while(n-- && fast != NULL) {
            fast = fast->next;
        }
        fast = fast->next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点
        while (fast != NULL) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummyHead->next;
    }
};
```

### 2.删除数组中的重复项目

![img](file:///C:\Users\ASUS\AppData\Roaming\Tencent\Users\1102067530\QQ\WinTemp\RichOle\IS4)NHWIQFM0ROPKY)}JDPE.png)![img](file:///C:\Users\ASUS\AppData\Roaming\Tencent\Users\1102067530\QQ\WinTemp\RichOle\T4EQIU(WE_EPDKYRZN5XL$B.png)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
    if(nums == null || nums.length == 0) return 0;
    int p = 0;
    int q = 1;
    while(q < nums.length){
        if(nums[p] != nums[q]){
            if(q - p > 1){
                nums[p + 1] = nums[q];
            }
            p++;
        }
        q++;
    }
    return p + 1;
}

}
```

解题思路：
解法： 双指针

首先注意数组是有序的，那么重复的元素一定会相邻。

要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。

考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：

1.比较 p 和 q 位置的元素是否相等。

如果相等，q 后移 1 位
如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位
重复上述过程，直到 q 等于数组长度。

返回 p + 1，即为新数组长度。
复杂度分析：

时间复杂度：O(n)O(n)。
空间复杂度：O(1)O(1)。

优化：

这是大部分题解都没有提出的，在这里提一下。

考虑如下数组：



此时数组中没有重复元素，按照上面的方法，每次比较时 nums[p] 都不等于 nums[q]，因此就会将 q 指向的元素原地复制一遍，这个操作其实是不必要的。

因此我们可以添加一个小判断，当 q - p > 1 时，才进行复制。

作者：max-LFszNScOfE
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 栈

## a.单调栈

### 1.柱状图里的最大矩形

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)



以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

 

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

 

示例:

输入: [2,1,5,6,2,3]
输出: 10

方法一：暴力解法
这道问题的暴力解法比「接雨水」那道题要其实好想得多：可以枚举以每个柱形为高度的最大矩形的面积。

具体来说就是：依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。

![image.png](https://pic.leetcode-cn.com/b4125f95419bc2306c7f16d1679c32e538b0b087bd9d0f70658c1a8528afca6b-image.png)

为此，我们需要：

左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；

右边看一下，看最多能向右延伸多长；找到大于等于当前柱形高度的最右边元素的下标。

对于每一个位置，我们都这样操作，得到一个矩形面积，求出它们的最大值。

复杂度分析：

时间复杂度：O(N^2)O(N 
2
 )，这里 NN 是输入数组的长度。
空间复杂度：O(1)O(1)。
看到时间复杂度为 O(N^2)O(N 
2
 ) 和空间复杂度为 O(1)O(1) 的组合，那么我们是不是可以一次遍历，不需要中心扩散就能够计算出每一个高度所对应的那个最大面积矩形的面积呢？

其实很容易想到的优化的思路就是「以空间换时间」。我们需要在遍历的过程中记录一些信息。

方法二：单调栈

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

![003.png](https://pic.leetcode-cn.com/b2a9787ca2402fe946a19d4170b28c6497040c0eb151f4bbdde0d61b49694697-003.png)


如上图，矩形最大面积为10。这个问题同样可以借助单调栈来解决。在这之前，需要理解如何找到这个最大面积矩形，这个矩形的限制条件有两个，一个是高度（也即组成矩形的最短的那根柱子高度），一个是宽度，（也即组成矩形的柱子个数）。为了找到这个全局最大值，我们遍历所有局部最优情况。那么什么是局部最优解呢，我们将每个柱子的高度作为包含它的矩形的高度，也即这个柱子一定是这个矩形中最低的一个柱子，那么我们下一步是求解这个矩形的宽度，显然我们只需找到这个柱子左边，右边第一个比它低的柱子，就可以求出宽度。这显然让我们想到使用单调栈的数据结构。

注意，由于边界的矩形左边或右边没有比它小的矩形，所以要在本来的heights向量中，前端和后端都要加个0的高度。

我的版本：

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.size()==1)
        return heights[0];
    stack<int>compare;//注意栈存储的是高度的索引值而不是高度本身，一定要注意。
    heights.push_back(0);
    heights.insert(heights.begin(),0);//前后端➕0
    int maxvalue=0;
    int area;
    int height=0;
    for(int i=0;i<heights.size();i++)
    {
        if(compare.empty())
        compare.push(i);
        else if(heights[i]>heights[compare.top()])
        {
            compare.push(i);
        }
        else
        {
             while(!compare.empty()&&heights[compare.top()]>heights[i])
             {
                 height=heights[compare.top()];//这里先记录栈顶的高度，然后接下来，i要减去原本栈顶元素的下一个元素（就是与它最近且比它小的那个高度的索引值再减去1）
                 compare.pop();//这里弹出栈顶元素，剩下那个就是原本栈顶元素的下一个元素（就是与它最近且比它小的那个高度）
                 maxvalue=max((i-compare.top()-1)*height,maxvalue);             
             }
             compare.push(i);
        }
    }
    return maxvalue;
    }
};
```

```c++
int largestRectangleArea(vector<int> heights) {
    int maxArea = 0;
    heights.push_back(0);
    stack<int> stk; //monotone stack(ascending)
    for(int i=0; i<heights.size(); i++) {
        while(!stk.empty() && heights[i] < heights[stk.top()]) {
            int top = stk.top();
            stk.pop(); //find the smaller element to the left of the current element
            maxArea = max(maxArea,heights[top]*(stk.empty() ? i : (i - stk.top()-1)));//注意这里
        }
        stk.push(i);    
    }
    
    return maxArea;
}
//改进版本
```

### 2.最大矩形



![image-20201029141736018](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201029141736018.png)

![image-20201029141832142](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201029141832142.png)

```c++
class Solution {
public:
    int result=0;
    int matrixsize;
    int height;

    int maximalRectangle(vector<vector<char>>& matrix) {
          if(matrix.size()==0)
          return 0;
          vector<int>heights(matrix[0].size()+2,0);
          matrixsize=matrix.size();
          for(int i=0;i<matrix.size();i++)
          {
              for(int j=0;j<matrix[0].size();j++)
              {
                  if(matrix[i][j]=='1')
                  heights[j+1]+=1;
                  else
                  heights[j+1]=0;
              }
              calculate(heights);
          }
          return result;
    }
    void calculate(vector<int>&heights)
    {
       stack<int>solution;
       for(int i=0;i<heights.size();i++)
       {
           if(solution.empty()||heights[i]>=heights[solution.top()])
           solution.push(i);
           else
           {
               while(heights[i]<heights[solution.top()])
               {
                   height=heights[solution.top()];
                   solution.pop();
                   result=max(result,(i-solution.top()-1)*height);
               }
               solution.push(i);
           }
       }
    }
};
```



# 二叉树

### 1.重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

​    3

   / \
  9  20
  /     \
15     7

子树特点： 子树的前序和中序遍历仍符合以上特点，以题目示例的右子树为例：前序遍历：[20 | 15 | 7]，中序遍历 [ 15 | 20 | 7 ] 。

根据子树特点，我们可以通过同样的方法对左（右）子树进行划分，每轮可确认三个节点的关系 。此递推性质让我们联想到用 递归方法 处理。
递归解析：
递推参数： 前序遍历中根节点的索引pre_root、中序遍历左边界in_left、中序遍历右边界in_right。
终止条件： 当 in_left > in_right ，子树中序遍历为空，说明已经越过叶子节点，此时返回null 。
递推工作：
建立根节点root： 值为前序遍历中索引为pre_root的节点值。
搜索根节点root在中序遍历的索引i： 为了提升搜索效率，本题解使用哈希表 dic 预存储中序遍历的值与索引的映射关系，每次搜索的时间复杂度为 O(1)O(1)。
构建根节点root的左子树和右子树： 通过调用 recur() 方法开启下一层递归。
左子树： 根节点索引为 pre_root + 1 ，中序遍历的左右边界分别为 in_left 和 i - 1。(i是在inorder序列中元素等于preorder【pre_root】的元素的索引值)
右子树： **根节点索引为 i - in_left + pre_root + 1（即：根节点索引 + 左子树长度 + 1**），中序遍历的左右边界分别为 i + 1 和 in_right。
返回值： 返回 root，含义是当前递归层级建立的根节点 root 为上一递归层级的根节点的左或右子节点。

复杂度分析

时间复杂度 O(N) ： N为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(N) ；递归共建立 N 个节点，每层递归中的节点建立、搜索操作占用 O(1)O(1) ，因此递归占用 O(N)O(N) 。（最差情况为所有子树只有左节点，树退化为链表，此时递归深度 O(N) ；平均情况下递归深度 O(log_2 N)O(log 2N) ）。

空间复杂度 O(N) ： HashMap 使用O(N) 额外空间；递归操作中系统需使用O(N) 额外空间。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    unordered_map<int,int> map;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        // 将中序序列用哈希表存储，便于查找根节点
        for(int i = 0;i < inorder.size();i++)
            map[inorder[i]] = i;
        // 传入参数：前序,中序，前序序列根节点，中序序列左边界，中序序列右边界
        return build(preorder,inorder,0,0,inorder.size()-1);
    }
    TreeNode* build(vector<int>& preorder, vector<int>& inorder,int pre_root,int in_left,int in_right){
        if(in_left > in_right)
            return NULL;
        TreeNode* root = new TreeNode(preorder[pre_root]);
        // 根节点在中序序列中的位置，用于划分左右子树的边界
        int in_root = map[preorder[pre_root]];
        // 左子树在前序中的根节点位于：pre_root+1,左子树在中序中的边界：[in_left,in_root-1]
        root->left = build(preorder,inorder,pre_root+1,in_left,in_root-1);
        // 右子树在前序中的根节点位于：根节点+左子树长度+1 = pre_root+in_root-in_left+1
        // 右子树在中序中的边界：[in_root+1,in_right]
        root->right = build(preorder,inorder,pre_root+in_root-in_left+1,in_root+1,in_right);
        return root;
    }
};
```

### 2.二叉树的层序遍历

![image-20201019094332604](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201019094332604.png)

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

**需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑**，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。(前中后序遍历，其实都是利用了栈的思想)

而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>>res;
        vector<int>middle;
        queue<TreeNode*>tree;
        if(root!=NULL)
        tree.push(root);
        else
        return res;
        while(!tree.empty())
        {
            int size=tree.size();//一定要先用size来存了刚进入循环的队列的size，因为在下面的操作里面size是会变的
            for(int i=0;i<size;i++)
            {
                TreeNode*node=tree.front();
                middle.push_back(node->val);
                if(node->left)tree.push(node->left);//依次首个treenode的左右结点压入队列
                if(node->right)tree.push(node->right);
                tree.pop();//首个treenode出队
            }
            res.push_back(middle);
            middle.clear();
        }
        return res;
    }
};
```



### 3.二叉树的锯齿形遍历

![image-20201020114903344](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201020114903344.png)

```c++

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
// class Solution {
// public:
//     vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
//         vector<vector<int>>res;
//         vector<int>middle;
//         deque<TreeNode*>tree;
//         if(root!=NULL)
//         tree.push_front(root);
//         else
//         return res;
//         int turn=true;//如果turn是true就是从左到右
//         while(!tree.empty())
//         {
//             int size=tree.size();//一定要先用size来存了刚进入循环的队列的size，因为在下面的操作里面size是会变的
//             for(int i=0;i<size;i++)
//             {   if(turn)
//                 {
//                     TreeNode*node=tree.front();
//                     middle.push_back(node->val);
//                     if(node->left)tree.push_back(node->left);
//                     if(node->right)tree.push_back(node->right);
//                     tree.pop_front();
//                 }
//                 else
//                 {
//                     TreeNode*node=tree.back();
//                     middle.push_back(node->val);
//                     if(node->right)tree.push_front(node->right);
//                     if(node->right)tree.push_front(node->left);
//                     tree.pop_back();
//                 }       
//             }
//             turn=!turn;
//             res.push_back(middle);
//             middle.clear();
//         }
//         return res;
//     }
// };class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if (!root) return ans;
        deque<TreeNode*> que;
        que.push_back(root);
        bool zigzag = true;//如果是true 那么就是从左到右遍历 就是前取后入 如果false则反之
        TreeNode* tmp;
        while (!que.empty()) {
            int Size = que.size();
            vector<int> tmp_vec;
            while (Size) { 
                if (zigzag) { //前取后放
                    tmp = que.front();
                    que.pop_front();
                    if (tmp->left) que.push_back(tmp->left); 
                    if (tmp->right) que.push_back(tmp->right);                
                } else { 
                    tmp = que.back();//后取前放
                    que.pop_back();
                    if (tmp->right) que.push_front(tmp->right);//记住先压右结点
                    if (tmp->left) que.push_front(tmp->left);
                }
                tmp_vec.push_back(tmp->val);
                --Size;
            }
            zigzag = !zigzag;
            ans.push_back(tmp_vec);
        }
        return ans;
    }
};
```

![5247da4a829bc8af4046262982794b8](C:\Users\ASUS\AppData\Local\Temp\WeChat Files\5247da4a829bc8af4046262982794b8.png)

![c4f851f77818e60a9a4cc1ae7953525](C:\Users\ASUS\AppData\Local\Temp\WeChat Files\c4f851f77818e60a9a4cc1ae7953525.png)

### 4.恢复二叉搜索树

![image-20201027175658826](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201027175658826.png)

![image-20201027175711316](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201027175711316.png)

一种比较低效但好理解的方法：先拿个vector存了原来二叉树中序遍历的结果，然后，我们排个序，然后再对原来二叉树进行一个中序遍历，这时候，我们把每一个节点的值和在vector中对应位置的值做个比较，如果不一样的话，那么把vector中的值给到树，这样就正确了。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int>nums;
    int times=0;//这里是索引值
    void recoverTree(TreeNode* root) {
        middleOver(root);//第一次中序遍历，把值压进去。
        sort(nums.begin(),nums.end());//排序
        recover(root);
    }
    void middleOver(TreeNode*root)
    {
        if(root==NULL)
        return;
        middleOver(root->left);
        nums.push_back(root->val);
        middleOver(root->right);
    }
    void recover(TreeNode*root)
    {
         if(root==NULL)
        {   times--;//这里由为关键，因为到了空的节点，相当于他在vector中是没有对应的值的，但在else语句中我们进行了++，所以要减回；
            return;
        }
         else
         {
             recover(root->left);
             times++;//因为先访问的是左子，那么先访问完再++才对。
             if(root->val!=nums[times])
             root->val=nums[times];
             times++;//右子是先访问了本节点再访问的，所以索引要++
             recover(root->right);            
         }
    }
};
```

### 5.不同的二叉树I(动规)

![image-20210419151201922](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210419151201922.png)

```java
class Solution {
    public int numTrees(int n) {
        if(n<=2)
        return n;
        int[] dp=new int[n+1];
        dp[0]=1;
        dp[1]=1;
        dp[2]=2;
        for(int i=3;i<=n;i++)
        {
            for(int j=0;j<=i-1;j++)
            dp[i]+=dp[j]*dp[i-j-1];
        }
        return dp[n];
    }
}
```



### 6.不同的二叉搜索树II

![image-20210315194905819](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210315194905819.png)

```c++
class Solution {
public:
    
    vector<TreeNode*> generateTrees(int n) {
        vector<TreeNode*> ret;
        if(n == 0)
            return ret;    
        ret = helper(1,n);
        return ret;
    }
    vector<TreeNode*>helper(int start,int end)
    {
        vector<TreeNode*>ret;
        if(start>end)
        ret.push_back(nullptr);
        else
        {
            for(int i=start;i<=end;i++)
            {
            //一定是算出来左子树的总的情况还有右子树的所有情况然后才赋值给本层的节点，这样才能通过。
            vector<TreeNode*>left=helper(start,i-1);
            vector<TreeNode*>right=helper(i+1,end);
            for(auto l:left)
            {
                for(auto r:right)
                {
                    TreeNode*root=new TreeNode(i);
                    root->left=l;
                    root->right=r;
                    ret.push_back(root);
                }
            }
            }
        }
        return ret;    
    }
};

    
```

### 7.对称的二叉树

![image-20210316184913187](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210316184913187.png)

思路
首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。

那么如果比较呢？

比较的是两个子树的里侧和外侧的元素是否相等。如图所示：

![image-20210316185017312](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210316185017312.png)

那么遍历的顺序应该是什么样的呢？

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。

但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。

其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。

说到这大家可能感觉我有点啰嗦，哪有这么多道理，上来就干就完事了。别急，我说的这些在下面的代码讲解中都有身影。

那么我们先来看看递归法的代码应该怎么写。

```c++
递归三部曲
确定递归函数的参数和返回值
因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

返回值自然是bool类型。

代码如下：


bool compare(TreeNode* left, TreeNode* right)
确定终止条件
要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

节点为空的情况有：

左节点为空，右节点不为空，不对称，return false
左不为空，右为空，不对称 return false
左右都为空，对称，返回true
此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

左右都不为空，比较节点数值，不相同就return false
此时左右节点不为空，且数值也不相同的情况我们也处理了。

代码如下：


if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true; 
else if (left->val != right->val) return false; // 注意这里我没有使用else
注意上面最后一种情况，我没有使用else，而是elseif， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。

确定单层递归的逻辑
此时才进入单层递归的逻辑，单层递归的逻辑就是处理 右节点都不为空，且数值相同的情况。

比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
比较内测是否对称，传入左节点的右孩子，右节点的左孩子。
如果左右都对称就返回true ，有一侧不对称就返回false 。
代码如下：


bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
bool isSame = outside && inside;                    // 左子树：中、 右子树：中（逻辑处理）
return isSame;
如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。

最后递归的C++整体代码如下：


class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};
我给出的代码并不简洁，但是把每一步判断的逻辑都清楚的描绘出来了。

如果上来就看网上各种简洁的代码，看起来真的很简单，但是很多逻辑都掩盖掉了，而题解可能也没有把掩盖掉的逻辑说清楚。

盲目的照着抄，结果就是：发现这是一道“简单题”，稀里糊涂的就过了，但是真正的每一步判断逻辑未必想到清楚。

当然我可以把如上代码整理如下：


class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        else if (left->val != right->val) return false;
        else return compare(left->left, right->right) && compare(left->right, right->left);

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};
这个代码就很简洁了，但隐藏了很多逻辑，条理不清晰，而且递归三部曲，在这里完全体现不出来。

所以建议大家做题的时候，一定要想清楚逻辑，每一步做什么。把道题目所有情况想到位，相应的代码写出来之后，再去追求简洁代码的效果。

作者：carlsun-2
链接：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/dui-cheng-er-cha-shu-di-gui-fa-die-dai-fa-xiang-ji/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```c++
迭代法
这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。

这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（注意这不是层序遍历）
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        while (!que.empty()) {  // 接下来就要判断这这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();    
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) { 
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};

作者：carlsun-2
链接：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/dui-cheng-er-cha-shu-di-gui-fa-die-dai-fa-xiang-ji/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null)
        return true;
        else
        return judge(root.left,root.right);
    }
    public boolean judge(TreeNode left,TreeNode right)
    {
        //分析终止条件
        if(left==null&&right==null)
        return true;
        else if(left==null||right==null)
        return false;
        else
        {
           //递归的单层逻辑
           boolean a=judge(left.left,right.right);
           boolean b=judge(left.right,right.left);
           boolean c=left.val==right.val;
           return a&&b&&c;
        }
    }
}
```

### 8.填充每个节点的下一个右侧节点指针I



![image-20210426142122805](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210426142122805.png)

![image-20210426142715099](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210426142715099.png)





![image-20210426142808643](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210426142808643.png)

![image-20210426142315053](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210426142315053.png)

```java
时间O(n) 空间O(n)方法
用层序遍历，然后每次在压入下一层元素之前，将队列中的每个元素指向它们自己的下一个元素
// LinkedList<Node>middle=new LinkedList<>();
        // middle.add(root);
        // Integer size;
        // while(middle.size()!=0)
        // {
        //     for(int i=0;i<middle.size()-1;i++)
        //     {
        //         middle.get(i).next=middle.get(i+1);
        //     }
        //     size=middle.size();
        //     for(int i=0;i<size;i++)
        //     {
        //         Node front=middle.get(0);
        //         middle.removeFirst();
        //         if(front.left!=null)
        //         middle.add(front.left);
        //         if(front.right!=null)
        //         middle.add(front.right);
        //     }
        // }
        // return root;
```

```java
class Solution {
	public Node connect(Node root) {
		if(root==null) {
			return root;
		}
		Node pre = root;
		//循环条件是当前节点的left不为空，当只有根节点
		//或所有叶子节点都出串联完后循环就退出了
		while(pre.left!=null) {
			Node tmp = pre;
			while(tmp!=null) {
				//将tmp的左右节点都串联起来
				//注:外层循环已经判断了当前节点的left不为空
				tmp.left.next = tmp.right;
				//下一个不为空说明上一层已经帮我们完成串联了
				if(tmp.next!=null) {
					tmp.right.next = tmp.next.left;
				}
				//继续右边遍历
				tmp = tmp.next;
			}
			//从下一层的最左边开始遍历
			pre = pre.left;
		}
		return root;
	}
}

```



### 9.填充每个节点的下一个右侧节点指针II

![image-20210428220739103](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210428220739103.png)

![image-20210428220757761](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210428220757761.png)



```java
//想法就是把每一层当做一个链表串起来！
class Solution{
 public Node connect(Node root) {
        if (root == null)
            return root;
        //cur我们可以把它看做是每一层的链表
        Node cur = root;
        while (cur != null) {
            //遍历当前层的时候，为了方便操作在下一
            //层前面添加一个哑结点（注意这里是访问
            //当前层的节点，然后把下一层的节点串起来）
            Node dummy = new Node(0);
            //pre表示访下一层节点的前一个节点
            Node pre = dummy;
            //然后开始遍历当前层的链表
            while (cur != null) {
                if (cur.left != null) {
                    //如果当前节点的左子节点不为空，就让pre节点
                    //的next指向他，也就是把它串起来
                    pre.next = cur.left;
                    //然后再更新pre
                    pre = pre.next;
                }
                //同理参照左子树
                if (cur.right != null) {
                    pre.next = cur.right;
                    pre = pre.next;
                }
                //继续访问这一行的下一个节点
                cur = cur.next;
            }
            //把下一层串联成一个链表之后，让他赋值给cur，
            //后续继续循环，直到cur为空为止
            cur = dummy.next;
        }
        return root;
    }
}
```



# 回溯

### 1.全排列（不能重复）

要注意全排列是要取树的子节点的，如果是子集问题，就取树上的所有节点。

很多同学在去重上想不明白，其实很多题解也没有讲清楚，反正代码是能过的，感觉是那么回事，稀里糊涂的先把题目过了。

这个去重为什么很难理解呢，所谓去重，其实就是使用过的元素不能重复选取。 这么一说好像很简单！

但是什么又是“使用过”，我们把排列问题抽象为树形结构之后，“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。

没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。

那么排列问题，既可以在 同一树层上的“使用过”来去重，也可以在同一树枝上的“使用过”来去重！

理解这一本质，很多疑点就迎刃而解了。
还要强调的是去重一定要对元素经行排序，这样我们才方便通过相邻的节点来判断是否重复使用了。

首先把示例中的 [1,1,2] （为了方便举例，已经排序），抽象为一棵树，然后在同一树层上对nums[i-1]使用过的话，进行去重如图：

![47.全排列II1.png](https://pic.leetcode-cn.com/1600397590-keFZFY-47.%E5%85%A8%E6%8E%92%E5%88%97II1.png)

图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。

```c++
class Solution {
private:
    vector<vector<int>> result;
    void backtracking (vector<int>& nums, vector<int>& vec, vector<bool>& used) {
        // 此时说明找到了一组
        if (vec.size() == nums.size()) {
            result.push_back(vec);
            return;
        }

        for (int i = 0; i < nums.size(); i++) {
            // 这里理解used[i - 1]非常重要 
            // used[i - 1] == true，说明同一树支nums[i - 1]使用过 
            // used[i - 1] == false，说明同一树层nums[i - 1]使用过
            // 如果同一树层nums[i - 1]使用过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) { 
                continue;
            }
            if (used[i] == false) {
                used[i] = true;
                vec.push_back(nums[i]);
                backtracking(nums, vec, used);
                vec.pop_back();
                used[i] = false;
            }
        }
    }

public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<bool> used(nums.size(), false);
        vector<int> vec;
        backtracking(nums, vec, used);
        return result;

    }
};

```

### 2.n皇后

![image-20201026101405552](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201026101405552.png)

![image-20201026101415426](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201026101415426.png)

```c++
class Solution {
public:
    vector<vector<string>>res;
    vector<int>columninfor;//记录每一行所放的皇后的列信息
    vector<vector<string>> solveNQueens(int n) {
     string sizes;
     for(int i=0;i<n;i++)
     {
         sizes+=".";
     }
    vector<string>middle(n,sizes);
    dfs(1,n,middle);
    return res; 
    }
    void dfs(int times,int n,vector<string>&middle)
    {
        if(times==n+1)
        {
            res.push_back(middle);
        }
        else
        {
        for(int i=0;i<n;i++)
        {
           middle[times-1][i]='Q';
           columninfor.push_back(i);
           if(ifvalid())
           {
              dfs(times+1,n,middle);
           }
           middle[times-1][i]='.';
           columninfor.pop_back();
        }
        }
    }
    bool ifvalid()
    {
        for(int i=0;i<columninfor.size()-1;i++)
        {
            for(int j=i+1;j<columninfor.size();j++)
            {
                if(columninfor[i]==columninfor[j])
                return false;
                if(abs(columninfor[i]-columninfor[j])==abs(i-j))
                return false;
            }
        }
        return true;
    }
};
```

要理解到的是，我们可以忽略行信息。做法就是我们从第一行开始遍历，在每一行中选任意一个位置，这样的话，就不用在检验是否合法的函数里面检验两个皇后在不在同一行了。那么，这时候压缩成了只用顾忌列信息。对于两个皇后来说，合法函数中的剪枝条件可以抽象成这样：第一种，两个皇后的列重合了，这是第一个要判断的。第二个，两个皇后在对角线上。这个比较难判断，但其实，本质上是，两个皇后是一个正方形的对角的时候，那么两个皇后就在同一条对角线上了，怎么写呢？就是两个的行数的差的绝对值和两个皇后的列数的差的绝对值是相同的，那么两个皇后就是一个正方形的两角，所以这也是不合法的。这么判断就可以了。

### 3.扫雷游戏

![image-20201114170116365](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201114170116365.png)

![image-20201114170133533](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201114170133533.png)

这里有一个点：这里的深度优先搜索，并不是单路径的问题，是要把递归层该点的相邻的所有点都进行探索和开辟，这就要在每一层依次走完相邻的八个点。

```c++
class Solution {
public:
    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        //如果点击的点是雷所在的点，就把地雷处改掉然后直接返回值
        if(board[click[0]][click[1]]=='M')
        {
            board[click[0]][click[1]]='X';
            return board;
        }
        else
        dfs(click[0],click[1],board);
        return board;
    }
    void dfs(int row,int column,vector<vector<char>>& board)
    {
        //对于每一个点，如果它这个点不存在，或者说它这个点不是空的点，我们都不进行处理
        if(row<0||row>board.size()-1||column<0||column>board[0].size()-1||board[row][column]!='E')
        return;
        //判断是否是置为B的一个bool值
        bool B=true;
        //计算附近的雷的个数
        int count=0;
        int startx=row-1>=0?row-1:0;
        int endx=row+1<=board.size()-1?row+1:board.size()-1;
        int starty=column-1>=0?column-1:0;
        int endy=column+1<=board[0].size()-1?column+1:board[0].size()-1;
        //这里是要遍历八个相邻的点
        for(int i=startx;i<=endx;i++)
        {
            for(int j=starty;j<=endy;j++)
            {
                if(board[i][j]=='M')
                {
                    //如果它附近有地雷，那很明显不是B
                    B=false;
                    count++;
                }
            }
        }
        int i=row;
        int j=column;
        if(B)
        {
            board[i][j]='B';
            dfs(i-1,j,board);
            dfs(i+1,j,board);
            dfs(i,j-1,board);
            dfs(i,j+1,board);
            dfs(i-1,j-1,board);
            dfs(i-1,j+1,board);
            dfs(i+1,j-1,board);
            dfs(i+1,j+1,board);
        }
        else
        {
            board[row][column]=count+'0';
        }
    }
};
```

```c++
class Solution {
public:
    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        M = board.size();
        N = board[0].size();
        bfs(board, click[0], click[1]);
        return board;
    }

private:
    int M;
    int N;
    
    bool outOfRange(int x, int y) {
        return (x < 0 || x >= M || y < 0 || y >= N);
    }
    
    void bfs(vector<vector<char>>& board, int sx, int sy) {
        queue<vector<int>> q;
        q.push({sx, sy});

        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto cur = q.front(); q.pop();
                auto x = cur[0];
                auto y = cur[1];
                if (board[x][y] == 'M') {
                    board[x][y] = 'X';
                    return;
                } else if (board[x][y] == 'E') {
                    int count = 0;
                    for (int i = -1; i <= 1; i++) {
                        for (int j = -1; j <= 1; j++) {
                            if (i == 0 && j == 0) {
                                continue;
                            }
                            auto nx = x + i;
                            auto ny = y + j;
                            if (!outOfRange(nx, ny)) {
                                count += board[nx][ny] == 'M';
                            }
                        }
                    }

                    if (count == 0) {
                        board[x][y] = 'B';
                        for (int i = -1; i <= 1; i++) {
                            for (int j = -1; j <= 1; j++) {
                                if (i == 0 && j == 0) {
                                    continue;
                                }

                                auto nx = x + i;
                                auto ny = y + j;
                                // dfs(board, nx, ny);
                                if (!outOfRange(nx, ny)) {
                                    q.push({nx, ny});
                                }
                            }
                        }
                    } else {
                        board[x][y] = '0' + count;
                        continue; // don't return inside while in BFS!!!
                    }
                }
            }
        }
    }
};
```

### 4.单词拆分2（让你写出解是怎样的，当然是深度优先，回溯）

### 5.单词搜索

![img](file:///C:\Users\ASUS\Documents\Tencent Files\1102067530\Image\C2C\C8TBSNPC0QH{GRG9FL][QXN.png)

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0; i < board.size(); i++){
            for(int j = 0; j < board[0].size(); j++){
                if(backtrack(board, word, 0, i , j)){ // 从二维表格的每一个格子出发
                    return true;
                }
            }
        }
        return false;
    }
private:
    bool backtrack(vector<vector<char>>& board, string& word, int wordIndex, int x, int y){
        if( board[x][y] != word[wordIndex]){ // 当前位的字母不相等，此路不通
            return false;
        }
        if(word.size() - 1  == wordIndex){ // 最后一个字母也相等, 返回成功
            return true;
        }
        char tmp = board[x][y]; 
        board[x][y] = 0; // 避免该位重复使用
        wordIndex++;
        if((x > 0 && backtrack(board, word, wordIndex, x - 1, y)) // 往上走 (此处多谢笑川兄指正)
        || (y > 0 && backtrack(board, word, wordIndex, x, y - 1)) // 往左走
        || (x < board.size() - 1 && backtrack(board, word, wordIndex, x + 1, y)) // 往下走
        || (y < board[0].size() - 1 && backtrack(board, word, wordIndex, x, y + 1))){ // 往右走
            return  true; // 其中一条能走通，就算成功
        }
        board[x][y] = tmp; // 如果都不通，则回溯上一状态
        return false;
    }
```

### 6.子集

![image-20210313113056802](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210313113056802.png)

```c++
//注意，这个就相当于各个条件的组合  就是 c51+c52+.....c55
class Solution {
public:
    vector<int>middle;
    vector<vector<int>>res;
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        res.push_back(middle);
        sort(nums.begin(),nums.end());
        vector<bool>ifvisit(nums.size());
        for(int i=1;i<=nums.size();i++)
        {
            dfs(nums,i,ifvisit,0);
        }
        return res;
    }
    void dfs(vector<int>&nums,int border,vector<bool>&ifvisit,int startIndex)
    {
        //注意，这不是排列，这是组合，一定startIndex，注意去重逻辑
        if(middle.size()==border)
        res.push_back(middle);
        else
        {
            for(int i=startIndex;i<nums.size();i++)
            {
                
                if(ifvisit[i])
                continue;
                //在同一树层的不压入
                else if(i>0&&!ifvisit[i-1]&&nums[i]==nums[i-1])
                continue;
                else
                {
                    middle.push_back(nums[i]);
                    ifvisit[i]=true;
                    dfs(nums,border,ifvisit,i+1);
                    ifvisit[i]=false;
                    middle.pop_back();
                }
            }
        }
    }
};
```

### 7.复原ip地址

![image-20210303112122296](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210303112122296.png)

```c++
class Solution {
public:
    vector<string>res;
    vector<int>middle;
    vector<string> restoreIpAddresses(string s) {
         dfs(s,0,1);
         return res;
    } 
    void dfs(string s,int startIndex,int times) 
    {
         //这里是进到第五次才进行判断，因为第四次时候，还要压一个数字进去middle
         if(times==5)
         {
            string hi;
            if(startIndex==s.size())
            {
                //如果startIndex已经是索引值s.size(),那自然就代表s的字符全部被利用完了啊
                for(int i=0;i<middle.size();i++)
                {
                    //拼接符合题意的字符串
                    hi+=to_string(middle[i]);
                    if(i<middle.size()-1)
                    hi.push_back('.');
                }
                res.push_back(hi);
            }
            else 
            return;
         }
         else
         {
             //这里注意要算一下border，因为剩下的字符当中，不一定都能凑成1，2，3位数，要看看剩多少个字符
             int border=s.size()-startIndex<3?s.size()-startIndex:3;
             for(int i=0;i<border;i++)
             {
                int number=cal(s,i+1,startIndex);
                if((i>0&&s[startIndex]=='0')||number>255)
                continue;               
                middle.push_back(number);
                dfs(s,startIndex+i+1,times+1);
                middle.pop_back();
             }
         }
    }
    int cal(string s,int num,int startIndex)
    {
        //计算返回某个想要计算的数字
        int number=0;
        for(int i=startIndex;i<startIndex+num;i++)
        number=number*10+(s[i]-'0');
        return number;

    }    
};
```

### 8.括号生成

![image-20210415190445601](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210415190445601.png)

当前左右括号都有大于 00 个可以使用的时候，才产生分支；
产生左分支的时候，只看当前是否还有左括号可以使用；
产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；
在左边和右边剩余的括号数都等于 00 的时候结算。

```java
class Solution {
    List<String>result=new LinkedList<>();
    StringBuilder middle=new StringBuilder();
    public List<String> generateParenthesis(int n) {
        if(n==1)
        result.add("()");
        else if(n==2)
        {
            result.add("()()");
            result.add("(())");
        }
        else
        {
            par_solution(n,n);
        }
        return result;
    }
    public void par_solution(int leftTimes,int rightTimes)
    {
        if (leftTimes > rightTimes) {
            return;
        }
        else if(rightTimes==0&&leftTimes==0)
        {
           result.add(middle.toString());
        }

        else
        {
            if(leftTimes!=0)
            {
                middle.append('(');
                par_solution(leftTimes-1,rightTimes);
                middle.deleteCharAt(middle.length()-1);
            }
            if(rightTimes!=0)
            {
                middle.append(')');
                par_solution(leftTimes,rightTimes-1);
                middle.deleteCharAt(middle.length()-1);
            }
        }
    }
}
```



# 深度优先

### 1.岛屿数量

![img](file:///C:\Users\ASUS\AppData\Roaming\Tencent\Users\1102067530\QQ\WinTemp\RichOle\JN82WOXWY)~FRL{WO4Z4061.png)

```c++
class Solution {
public:
    int res=0;
    int numIslands(vector<vector<char>>& grid) {
          for(int i=0;i<grid.size();i++)
          {
            for(int j=0;j<grid[0].size();j++)
            {
                if(grid[i][j]=='1')
                {
                    dfs(grid,i,j);
                    res++;
                }
            }
          }
          return res;
    }
    void dfs(vector<vector<char>>&grid,int i,int j)
    {
        if(i<0||i>grid.size()-1||j<0||j>grid[0].size()-1||grid[i][j]=='*'||grid[i][j]=='0')
        return;
        else
        {
            grid[i][j]='*';
            dfs(grid,i+1,j);
            dfs(grid,i-1,j);
            dfs(grid,i,j+1);
            dfs(grid,i,j-1);
        }

    }
    
};
```



# 排序

### 1.希尔排序

### 2.堆排序

步骤二的意思是，比如说一开始 ，我这个最初始的大顶堆的根和数组的末尾元素交换了，然后我们甩掉了数组末尾元素，将前面所有的数看成一个数组，然后这个数组再构成一个大顶堆，然后重复上述的操作。

![image-20201026153400932](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201026153400932.png)

![image-20201026153439004](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201026153439004.png)

![image-20201026153500230](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201026153500230.png)

![image-20201026153704703](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201026153704703.png)

![image-20201026153739549](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201026153739549.png)

![image-20201026153759896](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201026153759896.png)

```c++
#include <iostream>
#include <algorithm>
using namespace std;
 
void max_heapify(int arr[], int start, int end) 
{
    //建立父节点指标和子节点指标
    int dad = start;
    int son = dad * 2 + 1;
    while (son <= end)  //若子节点指标在范围内才做比较
    {    
        if (son + 1 <= end && arr[son] < arr[son + 1]) //先比较两个子节点大小，选择最大的
            son++;
        if (arr[dad] > arr[son]) //如果父节点大於子节点代表调整完毕，直接跳出函数
            return;
        else  //否则交换父子内容再继续子节点和孙节点比较
        {
            swap(arr[dad], arr[son]);
            dad = son;
            son = dad * 2 + 1;
        }
    }
}
 
void heap_sort(int arr[], int len) 
{
    //初始化，i从最後一个父节点开始调整
    for (int i = len / 2 - 1; i >= 0; i--)
        max_heapify(arr, i, len - 1);
    //先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕
    for (int i = len - 1; i > 0; i--) 
    {
        swap(arr[0], arr[i]);
        max_heapify(arr, 0, i - 1);
    }
}
 
void main() 
{
    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };
    int len = (int) sizeof(arr) / sizeof(*arr);
    heap_sort(arr, len);
    for (int i = 0; i < len; i++)
        cout << arr[i] << ' ';
    cout << endl;
    system("pause");
}
```



### 3.归并排序

**核心思想：归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。**

**图解（网上盗用）：**
**分治法**
“分”的步骤：
![这里写图片描述](https://img-blog.csdn.net/20180815112729271?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxeDEzNzYzMDU1MjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
“治”的步骤：
![这里写图片描述](https://img-blog.csdn.net/20180815112753617?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxeDEzNzYzMDU1MjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

详细“治”的步骤：
![这里写图片描述](https://img-blog.csdn.net/20180815112907211?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxeDEzNzYzMDU1MjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
![这里写图片描述](https://img-blog.csdn.net/20180815112915428?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxeDEzNzYzMDU1MjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
![这里写图片描述](https://img-blog.csdn.net/20180815112921220?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxeDEzNzYzMDU1MjY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（1）稳定性
　归并排序是一种稳定的排序。
（2）存储结构要求
　可用顺序存储结构。也易于在链表上实现。
（3）时间复杂度
　对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。
（4）空间复杂度
　 需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。
注意：若用单链表做存储结构，很容易给出就地的归并排序
归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。

```c++
template<typename T>
void merge_sort_recursive(T arr[], T reg[], int start, int end) {
    if (start >= end)
        return;
    int len = end - start, mid = (len >> 1) + start;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    merge_sort_recursive(arr, reg, start1, end1);
    merge_sort_recursive(arr, reg, start2, end2);
    int k = start;
    while (start1 <= end1 && start2 <= end2)
        reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
    while (start1 <= end1)
        reg[k++] = arr[start1++];
    while (start2 <= end2)
        reg[k++] = arr[start2++];
    for (k = start; k <= end; k++)
        arr[k] = reg[k];
}

// merge_sort
template<typename T>
void merge_sort(T arr[], const int len) {
    T reg[len];
    merge_sort_recursive(arr, reg, 0, len - 1);
}
```

### 4.快速排序

快速排序算法通过多次比较和交换来实现排序，其排序流程如下： 

(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 

(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。 

(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 

(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了



设要排序的[数组](https://baike.baidu.com/item/数组)是A[0]……A[N-1]，首先任意选取一个数据（通常选

[![快排图](https://bkimg.cdn.bcebos.com/pic/b7003af33a87e950707fdf2110385343fbf2b416?x-bce-process=image/resize,m_lfit,w_220,limit_1)](https://baike.baidu.com/pic/快速排序算法/369842/0/b7003af33a87e950707fdf2110385343fbf2b416?fr=lemma&ct=single)快排图

用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的[排序算法](https://baike.baidu.com/item/排序算法)，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 [1] 

一趟快速排序的算法是： [1] 

1）设置两个变量i、j，[排序](https://baike.baidu.com/item/排序)开始的时候：i=0，j=N-1； [1] 

2）以第一个数组元素作为关键数据，赋值给**key**，即**key**=A[0]； [1] 

3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于**key**的值A[j]，将A[j]和A[i]的值交换； [1] 

4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于**key**的A[i]，将A[i]和A[j]的值交换； [1] 

5）重复第3、4步，直到i==j； (3,4步中，没找到符合条件的值，即3中A[j]不小于**key**,4中A[i]不大于**key**的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。

假设一开始序列{xi}是：5，3，7，6，4，1，0，2，9，10，8。

此时，ref=5，i=1，j=11，从后往前找，第一个比5小的数是x8=2，因此序列为：2，3，7，6，4，1，0，5，9，10，8。

此时i=1，j=8，从前往后找，第一个比5大的数是x3=7，因此序列为：2，3，5，6，4，1，0，7，9，10，8。

此时，i=3，j=8，从第8位往前找，第一个比5小的数是x7=0，因此：2，3，0，6，4，1，5，7，9，10，8。

此时，i=3，j=7，从第3位往后找，第一个比5大的数是x4=6，因此：2，3，0，5，4，1，6，7，9，10，8。

此时，i=4，j=7，从第7位往前找，第一个比5小的数是x6=1，因此：2，3，0，1，4，5，6，7，9，10，8。

此时，i=4，j=6，从第4位往后找，直到第6位才有比5大的数，这时，i=j=6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序。

```c++
#include <iostream>
 
using namespace std;
 
void Qsort(int arr[], int low, int high){
    if (high <= low) return;
    int i = low;
    int j = high + 1;
    int key = arr[low];
    while (true)
    {
        /*从左向右找比key大的值*/
        while (arr[++i] < key)
        {
            if (i == high){
                break;
            }
        }
        /*从右向左找比key小的值*/
        while (arr[--j] > key)
        {
            if (j == low){
                break;
            }
        }
        if (i >= j) break;
        /*交换i,j对应的值*/
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    /*中枢值与j对应值交换*/
    int temp = arr[low];
    arr[low] = arr[j];
    arr[j] = temp;
    Qsort(arr, low, j - 1);
    Qsort(arr, j + 1, high);
}
 
int main()
{
    int a[] = {57, 68, 59, 52, 72, 28, 96, 33, 24};
 
    Qsort(a, 0, sizeof(a) / sizeof(a[0]) - 1);/*这里原文第三个参数要减1否则内存越界*/
 
    for(int i = 0; i < sizeof(a) / sizeof(a[0]); i++)
    {
        cout << a[i] << "";
    }
     
    return 0;
}
```

# 图

### 1.迪克斯特拉算法

作者：绝顶我为峰
链接：https://www.zhihu.com/question/20630094/answer/758191548
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



Dijkstra是目前各大 OIER 们最爱用的最短路算法了， Dijkstra 是单源最短路算法，不能处理带负边权的情况，用邻接矩阵或邻接表存图

下面我们来讲解一下它的思路：

我们找来一个图：



![img](https://pic4.zhimg.com/50/v2-31c513c9f890d7759e6b03ff4963c2bf_hd.jpg?source=1940ef5c)![img](https://pic4.zhimg.com/80/v2-31c513c9f890d7759e6b03ff4963c2bf_720w.jpg?source=1940ef5c)



假设它的起点是 a ，要求它到各点的最短距离

Dijkstra 思路是维护一个集合 s ，集合内的点是已经确定最短路的点，可以视为一个大整体，每次操作找出与集合相邻的点中距离起点最近的点加入集合中，并确定它的最短路为它的上家的最短路+该边权值，存在 dis 中

接下来图就要变丑了，请注意

第一步，我们先把 a 加入集合，不加粗的点为集合中的点，下同（ s={a} ; dis[]={0,∞,∞,∞,∞,∞,∞,∞}）：



![img](https://pic4.zhimg.com/50/v2-17dc01b0ba47e0b1a0510e3234ef9b2b_hd.jpg?source=1940ef5c)![img](https://pic4.zhimg.com/80/v2-17dc01b0ba47e0b1a0510e3234ef9b2b_720w.jpg?source=1940ef5c)



第二步，我们找出与集合相邻且距离起点最近的点 b ，把它加入集合，并确定它的最短路 0+2=2，存入数组（ s={a,b} ; dis[]={0,2,∞,∞,∞,∞,∞,∞}）：



![img](https://pic1.zhimg.com/50/v2-90fa887dd2c84e770e036c2dd64c7e08_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-90fa887dd2c84e770e036c2dd64c7e08_720w.jpg?source=1940ef5c)



第三步，我们找出与集合相邻且距离起点最近的点 d，把它加入集合，并确定它的最短路 2+1=3，存入数组（ s={a,b,d}; dis[]={0,2,∞,3,∞,∞,∞,∞} ）：



![img](https://pic1.zhimg.com/50/v2-767070c29251468c3bf540c8886cabcc_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-767070c29251468c3bf540c8886cabcc_720w.jpg?source=1940ef5c)



第四步，我们找出与集合相邻且距离起点最近的点 e，把它加入集合，并确定它的最短路 3+2=5（ s={a,b,d,e}; dis[]={0,2,∞,3,5,∞,∞,∞}）:



![img](https://pic1.zhimg.com/50/v2-029a1ce5f3289ea0c14c702a8ab28d30_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-029a1ce5f3289ea0c14c702a8ab28d30_720w.jpg?source=1940ef5c)



第五步，我们找出与集合相邻且距离起点最近的点 f，把它加入集合，并确定它的最短路 0+9=9 （ s={a,b,d,e,f} ; dis[]={0,2,∞,3,5,9,∞,∞} ）:



![img](https://pic1.zhimg.com/50/v2-04a286459ca07176b43dce4ee5b903b5_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-04a286459ca07176b43dce4ee5b903b5_720w.jpg?source=1940ef5c)



第六步，我们找出与集合相邻且距离起点最近的点 g ，把它加入集合，并确定它的最短路 5+7=12（ s={a,b,d,e,f,g}; dis[]={0,2,∞,3,5,9,12,∞} ）:



![img](https://pic2.zhimg.com/50/v2-fc35ca872d5bfa07513abb565f3ef85f_hd.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-fc35ca872d5bfa07513abb565f3ef85f_720w.jpg?source=1940ef5c)



第七步，我们找出与集合相邻且距离起点最近的点 c ，把它加入集合，并确定它的最短路 5+8=13（ s={a,b,c,d,e,f,g} ; dis[]={0,2,13,3,5,9,12,∞} ）:



![img](https://pic2.zhimg.com/50/v2-4b651d6a1a21bb9c632aa049328297d9_hd.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-4b651d6a1a21bb9c632aa049328297d9_720w.jpg?source=1940ef5c)



第八步，也是最后一步，我们找出与集合相邻且距离起点最近的点 h ，把它加入集合，并确定它的最短路 13+5=18 （ s={a,b,c,d,e,f,g,h} ; dis[]={0,2,13,3,5,9,12,18} ）:



![img](https://pic2.zhimg.com/50/v2-d847db73033cd605ee76bc2fb2e7ef13_hd.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-d847db73033cd605ee76bc2fb2e7ef13_720w.jpg?source=1940ef5c)



至此，整个图的最短路被我们求了出来， Dijkstra顺利完成！

理解了它的思路，那么怎么用代码实现呢？

先用邻接矩阵存储数据，考虑采用一个二重循环，每次寻找出距离集合最近的一个点，然后数组标记它已经加入集合，然后在用当前点对不在集合中的点进行松弛，进行 n*n* 次，整个操作就完成了（此处代码中默认起点是1）

```c++
void dijkstra()
{
    memset(dis,127/3,sizeof(dis));//初始化
    v[1]=1;
    dis[1]=0;
    for(int i=1;i<=n;++i)
    {
        int k=0;
        for(int j=1;j<=n;++j)//找出距离最近的点
            if(!v[j]&&(k==0||dis[j]<dis[k]))
                k=j;
        v[k]=1;//加入集合
        for(int j=1;j<=n;++j)//松弛
            if(!v[j]&&dis[k]+a[k][j]<dis[j])
                dis[j]=dis[k]+a[k][j];
    }
}

作者：绝顶我为峰
链接：https://www.zhihu.com/question/20630094/answer/758191548
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 2.课程表(拓扑排序)

这里要注意计算出度和入度，只有当入度减为0了再入队，不然会出错。靠自己的1方法是走不通的

![image-20210310151440520](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210310151440520.png)

```c++
// class Solution {
// public:
//     bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
//          if(prerequisites.size()==0)
//          return true;
//           vector<vector<int>>martix;
//           vector<bool>ifStart(numCourses,true);
//           vector<int>middle(numCourses);
//           for(int i=0;i<numCourses;i++)
//           martix.push_back(middle);
//           for(int i=0;i<prerequisites.size();i++)
//           {
//               int j=prerequisites[i][1];
//               int k=prerequisites[i][0];
//               martix[j][k]=1;
//               ifStart[k]=false;
//           }
//           queue<int>courses;
//           for(int i=0;i<ifStart.size();i++)
//           {
//               if(ifStart[i])
//               {
//                  courses.push(i);
//               } 
//           }
//           bool res=solution(martix,courses);
//           return res;
//     }
//     bool solution(vector<vector<int>>&martix,queue<int>courses)
//     {
//        int counter=0;   
//        while(courses.size()!=0)
//        {
//            int size=courses.size();
//            for(int i=0;i<size;i++)
//            { 
//               int startInt=courses.front();
//               counter++;
//               courses.pop();
//               for(int j=0;j<martix.size();j++)
//               {
//                   if(martix[startInt][j]==1)
//                   courses.push(j);
//               }
//            }
          
//        }
//        bool res=false;
//        if(counter==martix.size())
//        res=true;
//        return res;
//     } 
// };
这是我的版本，实际上这样子做会有重复
```

```c++
class Solution {
public:
   bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
	vector<int> v;
	vector<int> indegree(numCourses,0);
	vector<vector<int>> graph(numCourses,v);//构建临接表（用vector储存临接点，方便访问）
	
	/*vector<int> indegree(numCourses);
	vector<vector<int>> graph(numCourses);//构建临接表（用vector储存临接点，方便访问）
	vector<int> v;
	for (int i = 0; i < numCourses; i++)
	{
		indegree[i] = 0;
		graph.push_back(v);
	}*/
	for (int i = 0; i < prerequisites.size(); i++)
	{
		indegree[prerequisites[i][0]]++;
		graph[prerequisites[i][1]].push_back(prerequisites[i][0]);//存的是出边
	}
	//将入度为0的顶点入队
	queue<int> myqueue;
	for (int i = 0; i < numCourses; i++)
	{
		if (indegree[i] == 0)
			myqueue.push(i);
	}
	int cnt = 0;
	while (!myqueue.empty())
	{
		int temp = myqueue.front();
		myqueue.pop();
		cnt++;
		//更新：
		for (int i = 0; i < graph[temp].size(); i++)
		{
			indegree[graph[temp][i]]--;
			if (indegree[graph[temp][i]] == 0)//放在这里做！只判断邻接点。
				myqueue.push(graph[temp][i]);
		}		
	}
	return cnt == numCourses;

}
};
```



# 二分查找

### 概述

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法，**前提是数据结构必须先排好序，可以在数据规模的对数时间复杂度内完成查找。但是，二分查找要求线性表具有有随机访问的特点（例如数组），也要求线性表能够根据中间元素的特点推测它两侧元素的性质，以达到缩减问题规模的效果。**

二分查找问题也是面试中经常考到的问题，虽然它的思想很简单，但写好二分查找算法并不是一件容易的事情。

以下是二分查找的相关练习，可以帮助你进一步了解二分查找，快来试试吧！



# 链表

### 1.两两交换节点

![image-20210313112426099](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210313112426099.png)

递归版本:

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
           if(head==null)
           return null;
           else if(head.next==null)
           return head;
           else
           {
            ListNode temp=head.next.next;
            ListNode temp2=head.next;
            head.next.next=head;
            head.next=swapPairs(temp);
            head=temp2;
           }
           return head;
    }
使用递归来解决该题，主要就是递归的三部曲：
找终止条件：本题终止条件很明显，当递归到链表为空或者链表只剩一个元素的时候，没得交换了，自然就终止了。
找返回值：返回给上一层递归的值应该是已经交换完成后的子链表。
单次的过程：因为递归是重复做一样的事情，所以从宏观上考虑，只用考虑某一步是怎么完成的。我们假设待交换的俩节点分别为head和next，next的应该接受上一级返回的子链表(参考第2步)。就相当于是一个含三个节点的链表交换前两个节点，就很简单了，想不明白的画画图就ok。
```

迭代版本

![image-20210313112831145](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210313112831145.png)

![image-20210313112845420](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210313112845420.png)

![image-20210313112855883](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210313112855883.png)

![image-20210313112928918](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210313112928918.png)

### 2.删除链表重复节点I



![image-20210421103517785](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210421103517785.png)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
            if(head==null||head.next==null)
            return head;
            //结果的头结点
            ListNode res=head;
            //新链表的每个节点
            ListNode root=head;
            //middle是原链表的每个节点，不妨从head下一个节点开始
            ListNode middle=head.next;
            ListNode compare=head;
            while(middle!=null)
            {
                //如果middle的值跟需要比较的节点的值不同，那么就把middle塞进新的链表中
                //然后更换compare节点。
                if(middle.val!=compare.val)
                {
                    root.next=middle;
                    root=root.next;
                    compare=middle;
                }
                middle=middle.next;
            }
            //最后，root就是结果链表里面的最后一个非空节点，它的next节点应该要指向空。
            root.next=null;
            return res;
    }
}
```

### 2.删除链表重复节点II

![image-20210421104156815](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210421104156815.png)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
            if(head==null||head.next==null)
            return head;
            //双指针
            // 快指针在慢指针之后，一开始，快指针在慢指针的下一个位置，那么如果说慢指针所指
            // 节点的值是唯一的，那么慢指针的值一定不会等于快指针的值，所以如果两个值不相同，那么
            // 就可以把慢指针所指的节点加入到新的链表中。如果两个值相等，那么在快指针非空的情况下
            // 快指针一直向后移动，然后找到那个与慢指针的值不相同的节点，然后把快指针的值传给
            // 慢指针，那么快指针在非空的情况下指向自己的下一个节点，那么一直重复上述的步骤。
            // 最后，注意，因为fast==null的时候就跳出大循环，那么此时要注意slow指向的节点。如果说
            // slow是指向了空，那么代表slow此时是原来链表中的最后一个非空节点，代表这个节点的值
            // 其实是唯一的。那么如果它的next不是null，代表原链表中后面的所有节点的值都跟slow节点
            // 的值相同，那么就不应该把slow压进去！
            ListNode virtualHead=new ListNode(0);
            virtualHead.next=head;
            ListNode root=virtualHead;
            ListNode slow=head;
            ListNode fast=head.next;
            while(fast!=null)
            {
                if(fast.val!=slow.val)
                {
                   root.next=slow;
                   root=root.next;
                   fast=fast.next;
                   slow=slow.next;
                }
                else
                {
                    while(fast!=null&&fast.val==slow.val)
                    {
                        fast=fast.next;
                    }
                    if(fast!=null)
                    {
                        slow=fast;
                        fast=fast.next;
                    }
                }
            }
            if(slow.next==null)
            {
                 root.next=slow;
                 root=root.next;
            }
            root.next=null;
            return virtualHead.next;
            
    }
}
```

```java
lass Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode();
        ListNode tail = dummy;
        while (head != null) {
            // 进入循环时，确保了 head 不会与上一节点相同
            if (head.next == null || head.val != head.next.val) {
                tail.next = head;
                tail = head;
            }
            // 如果 head 与下一节点相同，跳过相同节点
            while (head.next != null && head.val == head.next.val) head = head.next;
            head = head.next;
        }
        tail.next = null;
        return dummy.next;
    }
}

```



# 哈希

### 1.字母异位词分组

![image-20210415182926417](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210415182926417.png)

```java
我的方法：利用哈希的思想，将每个单词的每个字母的ascll码值的四次方相加，然后得到一个值。如果是由相同的字母组成的单词，那么这个值就一定相同，那么用map来存储答案，一个这个值对应一个list。
// class Solution {
//     Map<Integer,LinkedList<String>>middle=new HashMap<>();
//     List<List<String>>res=new LinkedList<>();
//     public List<List<String>> groupAnagrams(String[] strs) {
//          for(String s :strs)
//          {
//               int r=sum(s);
                 //如果存在这个key，那么就直接把单词塞到这个链表就好了
//               if(middle.containsKey(r))
//               {
//                   middle.get(r).add(s);
//               }
//               else
//               {
                 //如果不存在这个key，那么就创造一个这个值对应的链表就好了
//                   LinkedList<String>list=new LinkedList();
//                   list.add(s);
//                   middle.put(r,list);
//               }
//          }
//          for(Integer key:middle.keySet())
//          {
//              res.add(middle.get(key));
//          }
//          return res;
//     }
//     public int sum(String s)
//     {
//         int sum=0;
//         for(int i=0;i<s.length();i++)
//         {
//              int middle=s.charAt(i)*s.charAt(i);
//              middle*=s.charAt(i);
//              middle*=s.charAt(i);
//              sum+=middle;
//         }
//         return sum;
//     }
// }
```

```java
class Solution{
public List<List<String>> groupAnagrams(String[] strs) {
    //边界条件判断
    if (strs == null || strs.length == 0)
        return new ArrayList<>();
    //map中key存储的是字符串中字母排序后新的字符串
    Map<String, List<String>> map = new HashMap<>();
    for (int i = 0; i < strs.length; i++) {
        //取出字符串，然后把它转化为字符数组
        char[] c = strs[i].toCharArray();
        //对字符数组进行排序
        Arrays.sort(c);
        //排序之后再把它转化为一个字符串
        String keyStr = String.valueOf(c);
        //判断map中有没有这个字符串，如果没有这个字符串，
        //说明还没有出现和这个字符串一样的字母异位词，
        //要新建一个list，把它存放到map中
        if (!map.containsKey(keyStr))
            map.put(keyStr, new ArrayList<>());
        //把字符串存放到对应的list中
        map.get(keyStr).add(strs[i]);
    }
    //最后返回
    return new ArrayList<>(map.values());
}
}

```

